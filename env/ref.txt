1c1,6
< import numpy as np
---
> """
> Author: Reuben Ferrante
> Date:   10/05/2017
> Description: This is the rocket lander simulation built on top of the gym lunar lander. It's made to be a continuous
>              action problem (as opposed to discretized).
> """
3d7
< import Box2D
5c9,11
< 
---
> import numpy as np
> import Box2D
> from gym.envs.classic_control import rendering
9,10d14
< from gym.envs.classic_control import rendering
< 
14d17
< 
17c20,21
< # contact detector similar to Lunar Lander
---
> 
> # This contact detector is equivalent the one implemented in Lunar Lander
19c23
<     '''
---
>     """
21c25
<     '''
---
>     """
36,40d39
<                 self.env.legs[i].ground_contact = True
< 
<     def end_contact(self, contact):
<         for i in range(2):
<             if self.env.legs[i] in [contact.fixtureA.body, contact.fixtureB.body]:
43,44d41
< # ----------------------------------------------------------------------------
< # ----------------------------------------------------------------------------
47,49c44,46
<     '''
<     Continuous Landing of a rocket.
<     '''
---
>     """
>     Continuous VTOL of a rocket.
>     """
51,52c48,49
<     'render.modes': ['human', 'rgb_array'],
<     'video.frames_per_second': FPS
---
>         'render.modes': ['human', 'rgb_array'],
>         'video.frames_per_second': FPS
55d51
<     # ----------------------------------------------------------------------------
74c70
<             self.observation_space = spaces.Box(-np.inf, np.inf, (settings.get('Observation Space Size'),))
---
>             self.observation_space = spaces.Box(-np.inf, +np.inf, (settings.get('Observation Space Size'),))
76c72
<             self.observation_space = spaces.Box(-np.inf, np.inf, (8,))
---
>             self.observation_space = spaces.Box(-np.inf, +np.inf, (8,))
87,90c83,86
<         # redefined to be a spaces.Box instance
<         self.action_space = spaces.Box(-np.inf, np.inf, (3,)) # Main Engine, Nozzle Angle, Left/Right Engine
< 
<         self.untransformed_state = [0] * 6 # Non-normalized state
---
>         self.action_space = spaces.Box(-np.inf, +np.inf, (3,)) # Main Engine, Nozzle Angle, Left/Right Engine
>         #self.action_space = [0, 0, 0]       # Main Engine, Nozzle Angle, Left/Right Engine
>         
>         self.untransformed_state = [0] * 6  # Non-normalized state
93a90
>     """ INHERITED """
95,97d91
<     ''' INHERITED '''
< 
<     # ----------------------------------------------------------------------------
102d95
<     # ----------------------------------------------------------------------------
130c123
<         # Adjust the initial coordinates of the rocket ***************
---
>         # Adjust the initial coordinates of the rocket
149c142
<         # step through one "passive" action
---
>         # Step through one action = [0, 0, 0] and return the state, reward etc.
152d144
<     # ----------------------------------------------------------------------------
164,166c156,157
<     # ----------------------------------------------------------------------------
<     def step(self, action):
<         assert(len(action) == 3)
---
>     def step(self, action): ####
>         assert len(action) == 3  # Fe, Fs, psi
168c159
<         # Check if contacted ground
---
>         # Check for contact with the ground
172c163
<         # Shutdown all Engines
---
>         # Shutdown all Engines upon contact with the ground
178c169
<             part.angle = self.lander.angle + float(action[2])
---
>             part.angle = self.lander.angle + float(action[2])  # This works better than motorSpeed
183c174,176
< 
---
>             # part.joint.motorSpeed = float(action[2]) # action[2] is in radians
>             # That means having a value of 2*pi will rotate at 360 degrees / second
>             # A transformation can be done on the action, such as clipping the value
185c178
<             part = self.lander 
---
>             part = self.lander
190c183
<         # Main FOrce Calculations
---
>         # Main Force Calculations
199c192
<         # Spending mass to get propulsion
---
>         # Decrease the rocket ass
202,205c195,198
<         # State Vector and records
<         self.previous_state = self.state 
<         state, self.untransformed_state = self.__generate_state()
<         self.state = state 
---
>         # State Vector
>         self.previous_state = self.state  # Keep a record of the previous state
>         state, self.untransformed_state = self.__generate_state()  # Generate state
>         self.state = state  # Keep a record of the new state
208c201,202
<         reward = self.__compute_rewards(state, m_power, s_power, part.angle)
---
>         reward = self.__compute_rewards(state, m_power, s_power,
>                                         part.angle)  # part angle can be used as part of the reward
209a204
>         # Check if the game is done, adjust reward based on the final state of the body
211,215c206,209
<             self.game_over, 
<             abs(state[XX]) >= 1.0, # out of x-space
<             state[YY] < 0 or state[YY] > 1.3, # out of y-space
<             abs(state[THETA]) > THETA_LIMIT # Rocket tilts beyond the nominal limit
<         ]
---
>             self.game_over,  # Evaluated depending on body contact
>             abs(state[XX]) >= 1.0,  # Rocket moves out of x-space
>             state[YY] < 0 or state[YY] > 1.3,  # Rocket moves out of y-space or below barge
>             abs(state[THETA]) > THETA_LIMIT]  # Rocket tilts greater than the "controllable" limit
226c220
<         return np.array(state), reward, done, {} # {} = info (required by parent class)
---
>         return np.array(state), reward, done, {}  # {} = info (required by parent class)
227a222
>     """ PROBLEM SPECIFIC - PHYSICS, STATES, REWARDS"""
229,232c224,225
<     ''' PROBLEM SPECIFIC -> PHYSICS , STATES, REWARDS'''
< 
<     # ----------------------------------------------------------------------------
<     def __main_engines_force_computation(self, action, rocketPart): # removed *args argument
---
>     def __main_engines_force_computation(self, action, rocketPart, *args):
>         # ----------------------------------------------------------------------------
240c233
<         dispersion = [self.np_random.uniform(-1.0, 1.0) / SCALE for _ in range(2)]
---
>         dispersion = [self.np_random.uniform(-1.0, +1.0) / SCALE for _ in range(2)]
242c235
<         # Main engine 
---
>         # Main engine
247,251c240,244
<                 # *******************************
<                 # original implementation was wrong, now clipping correctly
<                 m_power = np.clip(action[0], MAIN_ENGINE_LOWER, 1.0)
<                 assert(m_power >= MAIN_ENGINE_LOWER and m_power <= 1.0)
<                 ox = sin * (4 / SCALE + 2 * dispersion[0]) - cos * dispersion[1]
---
>                 m_power = (np.clip(action[0], 0.0, 1.0) + 1.0) * 0.3  # 0.5..1.0 # IS WRONG
>                 assert m_power >= 0.3 and m_power <= 1.0
>                 # ------------------------------------------------------------------------
>                 ox = sin * (4 / SCALE + 2 * dispersion[0]) - cos * dispersion[
>                     1]  # 4 is move a bit downwards, +-2 for randomness
254,256c247,251
<                 
<                 # particles as visual decoration
<                 p = self._create_particle(3.5, impulse_pos[0], impulse_pos[1], m_power, radius=7)
---
> 
>                 # rocketParticles are just a decoration, 3.5 is here to make rocketParticle speed adequate
>                 p = self._create_particle(3.5, impulse_pos[0], impulse_pos[1], m_power,
>                                           radius=7)
> 
262c257
<                 # Apply Forces
---
>                 # Force instead of impulse. This enables proper scaling and values in Newtons
266c261
<             print("Erro in main engine power.")
---
>             print("Error in main engine power.")
268c263
<         return m_power 
---
>         return m_power
270d264
<     # ----------------------------------------------------------------------------
271a266
>         # ----------------------------------------------------------------------------
273,274c268,269
<         dispersion = [self.np_random.uniform(-1.0, 1.0) / SCALE for _ in range(2)]
<         sin = math.sin(self.lander.angle) 
---
>         dispersion = [self.np_random.uniform(-1.0, +1.0) / SCALE for _ in range(2)]
>         sin = math.sin(self.lander.angle)  # for readability
277c272
<         y_dir = 1 # Positioning for side Thrusters
---
>         y_dir = 1 # Positioning for the side Thrusters
279,310c274,314
<         # side gas thrusters enabled and action[1] > 0.5
<         if (self.settings['Side Engines'] and (np.abs(action[1])) > SIDE_ENGINE_ACTIVATE):
<             # Orientation engines
<             engine_dir = np.sign(action[1])
<             s_power = np.clip(np.abs(action[1]), SIDE_ENGINE_ACTIVATE, 1.0)
<             assert(s_power >= SIDE_ENGINE_ACTIVATE and s_power <= 1.0)
< 
<             # Positioning
<             constant = (LANDER_LENGTH - SIDE_ENGINE_VERTICAL_OFFSET) / SCALE
<             dx_part1 = - sin * constant
<             dx_part2 = - cos * engine_dir * SIDE_ENGINE_AWAY / SCALE
<             dx = dx_part1 + dx_part2
<             dy = np.sqrt(np.square(constant) - np.square(dx_part1) * y_dir - sin * engine_dir * SIDE_ENGINE_AWAY / SCALE)
< 
<             # Forces -> I don't know where this 3 came from, but i'll keep it
<             ox = sin * dispersion[0] - cos * (3 * dispersion[1] + engine_dir * SIDE_ENGINE_AWAY / SCALE)
<             oy = -cos * dispersion[0] - sin * (3 * dispersion[1] + engine_dir * SIDE_ENGINE_AWAY / SCALE)
< 
<             # Impulse Position
<             impulse_pos = (self.lander.position[0] + dx, self.lander.position[1] + dy)
< 
<             # for plotting purposes
<             self.impulsePos = (self.lander.position[0] + dx, self.lander.position[1] + dy)
< 
<             try:
<                 p = self._create_particle(1, impulse_pos[0], impulse_pos[1], s_power, radius=3)
<                 p.ApplyForce((ox * SIDE_ENGINE_POWER * s_power, oy * SIDE_ENGINE_POWER * s_power), impulse_pos, True)
<                 self.lander.ApplyForce((-ox * SIDE_ENGINE_POWER * s_power, -oy * SIDE_ENGINE_POWER * s_power), impulse_pos, True)
< 
<             except:
<                 logging.error("Error due to Nan in calculating y during sqrt(l^2 - x^2). "
<                                 "x^2 > l^2 due to approximations on the order of approximately 1e-15.")
---
>         if (self.settings['Side Engines']):  # Check if side gas thrusters are enabled
>             if (np.abs(action[1]) > 0.5): # Have to be > 0.5
>                 # Orientation engines
>                 engine_dir = np.sign(action[1])
>                 s_power = np.clip(np.abs(action[1]), 0.5, 1.0)
>                 assert s_power >= 0.5 and s_power <= 1.0
> 
>                 # if (self.lander.worldCenter.y > self.lander.position[1]):
>                 #     y_dir = 1
>                 # else:
>                 #     y_dir = -1
> 
>                 # Positioning
>                 constant = (LANDER_LENGTH - SIDE_ENGINE_VERTICAL_OFFSET) / SCALE
>                 dx_part1 = - sin * constant  # Used as reference for dy
>                 dx_part2 = - cos * engine_dir * SIDE_ENGINE_AWAY / SCALE
>                 dx = dx_part1 + dx_part2
> 
>                 dy = np.sqrt(
>                     np.square(constant) - np.square(dx_part1)) * y_dir - sin * engine_dir * SIDE_ENGINE_AWAY / SCALE
> 
>                 # Force magnitude
>                 oy = -cos * dispersion[0] - sin * (3 * dispersion[1] + engine_dir * SIDE_ENGINE_AWAY / SCALE)
>                 ox = sin * dispersion[0] - cos * (3 * dispersion[1] + engine_dir * SIDE_ENGINE_AWAY / SCALE)
> 
>                 # Impulse Position
>                 impulse_pos = (self.lander.position[0] + dx,
>                                self.lander.position[1] + dy)
> 
>                 # Plotting purposes only
>                 self.impulsePos = (self.lander.position[0] + dx, self.lander.position[1] + dy)
> 
>                 try:
>                     p = self._create_particle(1, impulse_pos[0], impulse_pos[1], s_power, radius=3)
>                     p.ApplyForce((ox * SIDE_ENGINE_POWER * s_power, oy * SIDE_ENGINE_POWER * s_power), impulse_pos,
>                                  True)
>                     self.lander.ApplyForce((-ox * SIDE_ENGINE_POWER * s_power, -oy * SIDE_ENGINE_POWER * s_power),
>                                            impulse_pos, True)
>                 except:
>                     logging.error("Error due to Nan in calculating y during sqrt(l^2 - x^2). "
>                                   "x^2 > l^2 due to approximations on the order of approximately 1e-15.")
314d317
<     # ----------------------------------------------------------------------------
315a319
>         # ----------------------------------------------------------------------------
319c323
<         pos = self.lander. position
---
>         pos = self.lander.position
322c326,327
<         target = (self.initial_barge_coordinates[1][0] - self.initial_barge_coordinates[0][0]) / 2 + self.initial_barge_coordinates[0][0]
---
>         target = (self.initial_barge_coordinates[1][0] - self.initial_barge_coordinates[0][0]) / 2 + \
>                  self.initial_barge_coordinates[0][0]
325c330,332
<             (pos.y - (self.maximum_barge_height + (LEG_DOWN / SCALE))) / (W / 2) - LANDING_VERTICAL_CALIBRATION, 
---
>             (pos.y - (self.maximum_barge_height + (LEG_DOWN / SCALE))) / (W / 2) - LANDING_VERTICAL_CALIBRATION,
>             # affects controller
>             # self.bargeHeight includes height of helipad
328a336
>             # self.nozzle.angle,
336,339c344,347
<         return state, untransformed_state 
<     # ----------------------------------------------------------------------------
<     # part_angle left here to easily include if necessary
<     def __compute_rewards(self, state, main_engine_power, side_engine_power, part_angle): 
---
>         return state, untransformed_state
> 
>     # ['dx','dy','x_vel','y_vel','theta','theta_dot','left_ground_contact','right_ground_contact']
>     def __compute_rewards(self, state, main_engine_power, side_engine_power, part_angle):
341,345c349,364
<         # REWARD SHAPE -> MAY NEED TO ADAPT HERE
<         # ***************************
<         shaping = -200 * np.sqrt(np.square(state[0]) + np.square(state[1])) -100 * np.sqrt(np.square(state[2]) + np.square(state[3]))  \
<                     -1000 * abs(state[4]) - 30 * abs(state[5]) + 20 * state[6] + 20 * state[7]
<     
---
>         shaping = -200 * np.sqrt(np.square(state[0]) + np.square(state[1])) \
>                   - 100 * np.sqrt(np.square(state[2]) + np.square(state[3])) \
>                   - 1000 * abs(state[4]) - 30 * abs(state[5]) \
>                   + 20 * state[6] + 20 * state[7]
> 
>         # Introduce the concept of options by making reference markers wrt altitude and speed
>         # if (state[4] < 0.052 and state[4] > -0.052):
>         #     for i, (pos, speed, flag) in enumerate(zip(self.y_pos_ref, self.y_pos_speed, self.y_pos_flags)):
>         #         if state[1] < pos and state[3] > speed and flag is False:
>         #             shaping = shaping + 20
>         #             self.y_pos_flags[i] = True
>         #
>         #         elif state[1] < pos and state[3] < speed and flag is False:
>         #             shaping = shaping - 20
>         #             self.y_pos_flags[i] = True
> 
354c373
<         # penalize use of engines
---
>         # penalize the use of engines
357a377,378
>         # if self.settings['Vectorized Nozzle']:
>         #     reward += -100*np.abs(nozzle_angle) # Psi
360a382
>     """ PROBLEM SPECIFIC - RENDERING and OBJECT CREATION"""
362,366c384,385
<     ''' PROBLEM SPECIFIC - RENDERING AND OBJECT CREATION '''
< 
<     # ----------------------------------------------------------------------------
<     # Problem specific - LINKED (I do not understand what he means here)
<     def _create_terrain(self, chunks): 
---
>     # Problem specific - LINKED
>     def _create_terrain(self, chunks):
368c387,389
<         divisor_constant = 8 # render sea until where? 
---
>         # self.helipad_x1 = W / 5
>         # self.helipad_x2 = self.helipad_x1 + W / 5
>         divisor_constant = 8  # Control the height of the sea
372c393,394
<         height = np.random.normal(H / divisor_constant, 0.5, size=(chunks +1,))
---
>         # height = self.np_random.uniform(0, H / 6, size=(CHUNKS + 1,))
>         height = np.random.normal(H / divisor_constant, 0.5, size=(chunks + 1,))
373a396,397
>         # self.helipad_x1 = chunk_x[CHUNKS // 2 - 1]
>         # self.helipad_x2 = chunk_x[CHUNKS // 2 + 1]
376c400
<         height[chunks // 2 - 0] = self.helipad_y
---
>         height[chunks // 2 + 0] = self.helipad_y
380,387c404
<         return [0.33 * (height[i-1] + height[i] + height[i+1]) for i in range(chunks)], chunk_x # smoothed Y
< 
<     # ----------------------------------------------------------------------------
<     def _create_rocket(self, initial_coordinates=(W / 2, H / 1.2)): # carteadex
<         #body_color = (1, 1, 1) # original: white color
<         body_color = (1, 172.0 / 255.0 , 28.0 / 255.0) # new: bright orange
<         secondary_color = (0, 0, 0) # black
<         third_color = (0, 0, 0) # nozzle
---
>         return [0.33 * (height[i - 1] + height[i + 0] + height[i + 1]) for i in range(chunks)], chunk_x  # smoothed Y
388a406,409
>     # Problem specific - LINKED
>     def _create_rocket(self, initial_coordinates=(W / 2, H / 1.2)):
>         body_color = (1, 1, 1)
>         # ----------------------------------------------------------------------------------------
389a411
> 
398,400c420,422
<                 categoryBits=0x0010, # ????
<                 maskBits=0x001, # collide only with ground
<                 restitution=0.0) 
---
>                 categoryBits=0x0010,
>                 maskBits=0x001,  # collide only with ground
>                 restitution=0.0)  # 0.99 bouncy
403c425
<         self.lander.color2 = secondary_color
---
>         self.lander.color2 = (0, 0, 0)
406d427
<             # ORIGINAL CODE HERE WAS BAD, CHANGED
408,409c429,430
<                 self.np_random.uniform(-INITIAL_RANDOM_FORCE, INITIAL_RANDOM_FORCE),
<                 self.np_random.uniform(-4.0 * INITIAL_RANDOM_FORCE, -3.0 * INITIAL_RANDOM_FORCE) # CONSTANTS ARE (SOMEWHAT) ARBITRARY
---
>                 self.np_random.uniform(-INITIAL_RANDOM_FORCE * 0.3, INITIAL_RANDOM_FORCE * 0.3),
>                 self.np_random.uniform(-1.3 * INITIAL_RANDOM_FORCE, -INITIAL_RANDOM_FORCE)
414,440c435,438
<         # CAP
<         # self.cap = self.world.CreateDynamicBody(
<         #         position=(initial_x, initial_y + LANDER_LENGTH),
<         #         angle=0,
<         #         fixtures=fixtureDef(
<         #             shape=polygonShape(vertices=[(x / SCALE, y / SCALE) for x, y in CAP_POLY]),
<         #             density=5.0,
<         #             restitution=0.0,
<         #             categoryBits=0x0080,
<         #             maskBits=0x003) # collide only with ground
<         #     )
<         # self.cap.ground_contact = False
<         # self.cap.color1 = third_color
<         # self.cap.color2 = secondary_color
<         # rjd = revoluteJointDef(
<         #     bodyA=self.lander,
<         #     bodyB=self.cap,
<         #     localAnchorA=(0, 0),
<         #     localAnchorB=(0, 0),
<         #     enableMotor=True,
<         #     enableLimit=True,
<         #     maxMotorTorque=LEG_SPRING_TORQUE,
<         #     motorSpeed=0,
<         #     referenceAngle=0,
<         # )
<         # self.cap.joint = self.world.CreateJoint(rjd)
< 
---
>         # COG is set in the middle of the polygon by default. x = 0 = middle.
>         # self.lander.mass = 25
>         # self.lander.localCenter = (0, 3) # COG
>         # ----------------------------------------------------------------------------------------
446c444
<                 angle=(i * 0.05), # carteado mas vou manter
---
>                 angle=(i * 0.05),
456c454
<             leg.color2 = secondary_color
---
>             leg.color2 = (0, 0, 0)
460c458
<                 localAnchorA=(-i * 0.3, 0), # again, another set of carteação
---
>                 localAnchorA=(-i * 0.3, 0),
465c463
<                 motorSpeed=+0.3 * i  
---
>                 motorSpeed=+0.3 * i  # low enough not to jump back into the sky
468c466
<                 rjd.lowerAngle = 40 * DEGTORAD # nice constants
---
>                 rjd.lowerAngle = 40 * DEGTORAD
475c473
< 
---
>         # ----------------------------------------------------------------------------------------
485,486c483,484
<                 maskBits=0x003, # collide only with ground
<                 restitution=0.0) 
---
>                 maskBits=0x003,  # collide only with ground
>                 restitution=0.0)  # 0.99 bouncy
488,489c486,487
<         self.nozzle.color1 = third_color
<         self.nozzle.color2 = secondary_color
---
>         self.nozzle.color1 = (0, 0, 0)
>         self.nozzle.color2 = (0, 0, 0)
500,501c498,499
<             lowerAngle=NOZZLE_ANGLE_LIMIT+1, # less carteado than the original
<             upperAngle=NOZZLE_ANGLE_LIMIT-1
---
>             lowerAngle=-13 * DEGTORAD,  # +- 15 degrees limit applied in practice
>             upperAngle=13 * DEGTORAD
503c501
<         # rotate without resistance
---
>         # The default behaviour of a revolute joint is to rotate without resistance.
505,506c503,504
<         # LET'S DRAW THE ROCKET
<         #self.drawlist = self.legs + [self.nozzle] + [self.lander] + [self.cap]
---
>         # ----------------------------------------------------------------------------------------
>         # self.drawlist = [self.nozzle] + [self.lander] + self.legs
512c510
<     # ----------------------------------------------------------------------------
---
>     # Problem specific - LINKED
514a513
>         # The Barge can be modified in shape and angle
517c516,518
<         assert BARGE_LENGTH_X1_RATIO < BARGE_LENGTH_X2_RATIO, 'Barge Length X1 must be 0-1 and smaller than X2' 
---
>         # self.landingBargeCoordinates = [(self.helipad_x1, 0.1), (self.helipad_x2, 0.1),
>         #                                 (self.helipad_x2, self.bargeHeight), (self.helipad_x1, self.bargeHeight)]
>         assert BARGE_LENGTH_X1_RATIO < BARGE_LENGTH_X2_RATIO, 'Barge Length X1 must be 0-1 and smaller than X2'
521c522,524
<         self.landing_barge_coordinates = [(x1,0.1), (x2,0.1), (x2,self.bargeHeight), (x1,self.bargeHeight)]
---
>         self.landing_barge_coordinates = [(x1, 0.1), (x2, 0.1),
>                                           (x2, self.bargeHeight), (x1, self.bargeHeight)]
> 
524a528,532
>         # Used for the actual area inside the Barge
>         # barge_length = self.helipad_x2 - self.helipad_x1
>         # padRatio = 0.2
>         # self.landingPadCoordinates = [self.helipad_x1 + barge_length * padRatio,
>         #                               self.helipad_x2 - barge_length * padRatio]
527c535,537
<         self.landing_pad_coordinates = [x1 + barge_length * padRatio, x2 - barge_length * padRatio]
---
>         self.landing_pad_coordinates = [x1 + barge_length * padRatio,
>                                         x2 - barge_length * padRatio]
> 
530c540
<     # ----------------------------------------------------------------------------
---
>     # Problem specific - LINKED
539c549
<         self.main_base = self.world.CreateStaticBody(shapes=edgeShape(vertices=[(0, 0),(W, 0)]))
---
>         self.main_base = self.world.CreateStaticBody(shapes=edgeShape(vertices=[(0, 0), (W, 0)]))
542c552
<             p2 = (chunk_x[i + 1], smooth_y[i+1])
---
>             p2 = (chunk_x[i + 1], smooth_y[i + 1])
544,545c554,556
<             
<             self.sky_polys.append([p1, p2, (p2[0], H), (p1[0], 0)])
---
>             self.sky_polys.append([p1, p2, (p2[0], H), (p1[0], H)])
> 
>             self.ground_polys.append([p1, p2, (p2[0], 0), (p1[0], 0)])
548,549c559,560
<                 k = 1 - (j+1) / SEA_CHUNKS
<                 self.sea_polys[j].append([(p1[0],p1[1]* k), (p2[0],p2[1] * k), (p2[0], 0), (p1[0], 0)])
---
>                 k = 1 - (j + 1) / SEA_CHUNKS
>                 self.sea_polys[j].append([(p1[0], p1[1] * k), (p2[0], p2[1] * k), (p2[0], 0), (p1[0], 0)])
553d563
<     # ----------------------------------------------------------------------------
562d571
<     # ----------------------------------------------------------------------------
568,569c577
<             friction=friction
<         )
---
>             friction=friction)
572d579
<     # ----------------------------------------------------------------------------
574c581,589
<         ''' Only visual effects'''
---
>         """
>         Used for both the Main Engine and Side Engines
>         :param mass: Different mass to represent different forces
>         :param x: x position
>         :param y:  y position
>         :param ttl:
>         :param radius:
>         :return:
>         """
583c598
<                 maskbits=0x001, # collide only with ground
---
>                 maskBits=0x001,  # collide only with ground
586c601
<         p.ttl = ttl
---
>         p.ttl = ttl  # ttl is decreased with every time step to determine if the particle should be destroyed
587a603
>         # Check if some particles need cleaning
590,591c606
<         
<     # ----------------------------------------------------------------------------
---
> 
596d610
<     # ----------------------------------------------------------------------------
600a615
>         initial_y = (VIEWPORT_H * np.random.uniform(y_range[0], y_range[1], 1)) / SCALE
602d616
<         initial_y = (VIEWPORT_W * np.random.uniform(y_range[0], y_range[1], 1)) / SCALE
605c619
<         x_step = np.linspace(initial_x, initial_x + np.random.uniform(1,6), numberofdiscretepoints + 1)
---
>         x_step = np.linspace(initial_x, initial_x + np.random.uniform(1, 6), numberofdiscretepoints + 1)
612d625
<     # ----------------------------------------------------------------------------
616,617c629,630
<             self.clouds.append(self._create_cloud([0.2,0.4], [0.65,0.7], 1))
<             self.clouds.append(self._create_cloud([0.7,0.8], [0.75,0.8], 1))
---
>             self.clouds.append(self._create_cloud([0.2, 0.4], [0.65, 0.7], 1))
>             self.clouds.append(self._create_cloud([0.7, 0.8], [0.75, 0.8], 1))
621,622d633
<         # ****************
<         # Here, obviously need changes
624c635
<         self.lander.mass -= consumed_fuel
---
>         self.lander.mass = self.lander.mass - consumed_fuel
629d639
<     # ----------------------------------------------------------------------------
635,636c645,646
<             labels_dict[text] = pyglet.text.Label(text, font_size=15, x=W/2, y=H/2,
<                                                     anchor_x='right', anchor_y='center', color=(0, 255, 0, 255))
---
>             labels_dict[text] = pyglet.text.Label(text, font_size=15, x=W / 2, y=H / 2,  # - y_spacing*H/10,
>                                                   anchor_x='right', anchor_y='center', color=(0, 255, 0, 255))
639a650
>     """ RENDERING """
641,643d651
<     ''' RENDERING '''
< 
<     # ----------------------------------------------------------------------------
650c658,662
<         if self.viewer is None:
---
> 
>         # This can be removed since the code is being update to utilize env.refresh() instead
>         # Kept here for backwards compatibility purposes
>         # Viewer Creation
>         if self.viewer is None:  # Initial run will enter here
656c668,673
<         self.draw_marker(x=self.lander.worldCenter.x, y=self.lander.worldCenter.y)
---
>         self.draw_marker(x=self.lander.worldCenter.x, y=self.lander.worldCenter.y)  # Center of Gravity
>         # self.drawMarker(x=self.impulsePos[0], y=self.impulsePos[1])              # Side Engine Forces Positions
>         # self.drawMarker(x=self.lander.position[0], y=self.lander.position[1])    # (0,0) position
> 
>         # Commented out to be able to draw from outside the class using self.refresh
>         # return self.viewer.render(return_rgb_array=mode == 'rgb_array')
658d674
<     # ----------------------------------------------------------------------------
660c676,682
<         '''Used to draw user defined drawings'''
---
>         """
>         Used instead of _render in order to draw user defined drawings from controllers, e.g. trajectories
>         for the MPC or a a marking e.g. Center of Gravity
>         :param mode:
>         :param render:
>         :return: Viewer
>         """
662c684
<         if self.viewer is None:
---
>         if self.viewer is None:  # Initial run will enter here
668d689
< 
671d691
<     # ----------------------------------------------------------------------------
672a693,695
>         # --------------------------------------------------------------------------------------------------------------
>         # Rocket Lander
>         # --------------------------------------------------------------------------------------------------------------
681,682c704
<                                             lineWidth=2).add_attr(t)
< 
---
>                                             linewidth=2).add_attr(t)
683a706
>                     # Lander
689d711
<     # ----------------------------------------------------------------------------
692c714
<             self.viewer.draw_polygon(x, color=(1.0, 1.0, 1.0)) # white
---
>             self.viewer.draw_polygon(x, color=(1.0, 1.0, 1.0))
694d715
<     # ----------------------------------------------------------------------------
703d723
<     # ----------------------------------------------------------------------------
704a725,727
>         # --------------------------------------------------------------------------------------------------------------
>         # ENVIRONMENT
>         # --------------------------------------------------------------------------------------------------------------
705a729
> 
707a732
> 
717c742
<                 self.viewer.draw_polygon(poly, color=(0, 0.5*k, 1.0*k+0.5))
---
>                 self.viewer.draw_polygon(poly, color=(0, 0.5 * k, 1.0 * k + 0.5))
719c744
<         if self.settings['Clouds']:
---
>         if self.settings["Clouds"]:
727c752
<             polygon_coordinates = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
---
>             polygon_coordinates = [(x, flagy2), (x, flagy2 - 10 / SCALE), (x + 25 / SCALE, flagy2 - 5 / SCALE)]
731a757
>         # --------------------------------------------------------------------------------------------------------------
733c759
<     ''' CALLABLE DURING RUNTIME'''
---
>     """ CALLABLE DURING RUNTIME """
735d760
<     # ----------------------------------------------------------------------------
737c762,767
<         '''draws a black '+' sign at the x and y coordinates'''
---
>         """
>         Draws a black '+' sign at the x and y coordinates.
>         :param x: normalized x position (0-1)
>         :param y: normalized y position (0-1)
>         :return:
>         """
739,740c769,781
<         self.viewer.draw_polyline([(x, y-offset), (x, y+offset)], linewidth=2)
<         self.viewer.draw_polyline([(x-offset, y), (x+offset, y)], linewidth=2)
---
>         self.viewer.draw_polyline([(x, y - offset), (x, y + offset)], linewidth=2)
>         self.viewer.draw_polyline([(x - offset, y), (x + offset, y)], linewidth=2)
> 
>     def draw_polygon(self, color=(0.2, 0.2, 0.2), **kwargs):
>         # path expected as (x,y)
>         if self.viewer is not None:
>             path = kwargs.get('path')
>             if path is not None:
>                 self.viewer.draw_polygon(path, color=color)
>             else:
>                 x = kwargs.get('x')
>                 y = kwargs.get('y')
>                 self.viewer.draw_polygon([(xx, yy) for xx, yy in zip(x, y)], color=color)
742d782
<     # ----------------------------------------------------------------------------
746d785
<     # ----------------------------------------------------------------------------
749c788
<             self.landing_barge_coordinates[0][0]+x_movement, self.landing_barge_coordinates[0][1])
---
>             self.landing_barge_coordinates[0][0] + x_movement, self.landing_barge_coordinates[0][1])
751c790
<             self.landing_barge_coordinates[1][0]+x_movement, self.landing_barge_coordinates[1][1])
---
>             self.landing_barge_coordinates[1][0] + x_movement, self.landing_barge_coordinates[1][1])
753c792
<             self.landing_barge_coordinates[2][0]+x_movement, self.landing_barge_coordinates[2][1]+right_height)
---
>             self.landing_barge_coordinates[2][0] + x_movement, self.landing_barge_coordinates[2][1] + right_height)
755c794
<             self.landing_barge_coordinates[3][0]+x_movement, self.landing_barge_coordinates[3][1]+left_height)
---
>             self.landing_barge_coordinates[3][0] + x_movement, self.landing_barge_coordinates[3][1] + left_height)
762,763c801
<         
<     # ----------------------------------------------------------------------------
---
> 
768d805
<     # ----------------------------------------------------------------------------
770,771c807,809
<         x = (self.landing_barge_coordinates[1][0]-self.landing_barge_coordinates[0][0])/2 + self.landing_barge_coordinates[0][0]
<         y = abs(self.landing_barge_coordinates[2][1] - self.landing_barge_coordinates[3][1])/2 + \
---
>         x = (self.landing_barge_coordinates[1][0] - self.landing_barge_coordinates[0][0]) / 2 + \
>             self.landing_barge_coordinates[0][0]
>         y = abs(self.landing_barge_coordinates[2][1] - self.landing_barge_coordinates[3][1]) / 2 + \
775d812
<     # ----------------------------------------------------------------------------
779d815
<     # ----------------------------------------------------------------------------
785,786c821,824
<         return flatten_array([state, [self.remaining_fuel, self.lander.mass],
<                              self.get_barge_top_edge_points(), self.get_landing_coordinates()])
---
>         return flatten_array([state, [self.remaining_fuel,
>                                       self.lander.mass],
>                                       self.get_barge_top_edge_points(),
>                                       self.get_landing_coordinates()])
788d825
<     # ----------------------------------------------------------------------------
790c827,830
<         ''' Calculates the max barge height offset from the start to end'''
---
>         """
>         Calculates the max barge height offset from the start to end
>         :return:
>         """
793c833,834
<         barge_height_offset = initial_barge_coordinates[:, 1]-current_barge_coordinates[:, 1]
---
> 
>         barge_height_offset = initial_barge_coordinates[:, 1] - current_barge_coordinates[:, 1]
796d836
<     # ----------------------------------------------------------------------------
810d849
<     # ----------------------------------------------------------------------------
814d852
<     # ----------------------------------------------------------------------------
818d855
<     # ----------------------------------------------------------------------------
823d859
<     # ----------------------------------------------------------------------------
825,826d860
<         # ***********************
<         # WILL NEED CHANGES
828c862,863
<         theta = self.untransfored_state[THETA]
---
>         theta = self.untransformed_state[THETA]
>         # -----------------------------
834,835c869
<     # ----------------------------------------------------------------------------
<     def apply_random_x_disturbance(self, epsilon, left_or_right, x_force=2000): # carteação maximus
---
>     def apply_random_x_disturbance(self, epsilon, left_or_right, x_force=2000):
842d875
<     # ----------------------------------------------------------------------------
847d879
<     # ----------------------------------------------------------------------------
853c885
<                 self.move_barge(x_movement=-x_movement, left_height=0, right_height=0)                
---
>                 self.move_barge(x_movement=-x_movement, left_height=0, right_height=0)
855d886
<     # ----------------------------------------------------------------------------
858a890
> 
860a893
> 
862a896
> 
864a899
> 
870d904
<     # ----------------------------------------------------------------------------
875,876c909,912
<                 self.lander.ApplyForceToCenter((self.np_random.uniform(x),
<                     self.np_random.uniform(y)), True)
---
>                 self.lander.ApplyForceToCenter((
>                     self.np_random.uniform(x),
>                     self.np_random.uniform(y)
>                 ), True)
880d915
<     # ----------------------------------------------------------------------------
896c931
<         ss = (state_target-abs(np.array(state)))
---
>         ss = (state_target - abs(np.array(state)))
899,900d933
<     ''' ROCKETLANDER CLASS METHODS ARE OVER '''
<     ''' AUXILIARY FUNCTIONS AND COMPUTATIONS BELOW '''
902d934
< # ----------------------------------------------------------------------------
905,912c937,944
<                             'Clouds': False,
<                             'Vectorized Nozzle': True,
<                             'Graph': False,
<                             'Render': False,
<                             'Starting Y-Pos Constant': 1,
<                             'Initial Force': 'random',
<                             'Rows': 1,
<                             'Columns': 2}
---
>                            'Clouds': False,
>                            'Vectorized Nozzle': True,
>                            'Graph': False,
>                            'Render': False,
>                            'Starting Y-Pos Constant': 1,
>                            'Initial Force': 'random',
>                            'Rows': 1,
>                            'Columns': 2}
919c951
<         psi = np.random.uniform(-90*DEGTORAD, 90*DEGTORAD)
---
>         psi = np.random.uniform(-90 * DEGTORAD, 90 * DEGTORAD)
921c953
<         s, _, done, _ = env.step(action)  # r and info not used here
---
>         s, r, done, info = env.step(action)
932,934d963
< # ----------------------------------------------------------------------------
< def flatten_array(in_list):
<     return list(chain.from_iterable(in_list))
936,937c965,969
< # ----------------------------------------------------------------------------
< def compute_derivatives(state, action, sample_time=1/FPS):
---
> def flatten_array(the_list):
>     return list(chain.from_iterable(the_list))
> 
> 
> def compute_derivatives(state, action, sample_time=1 / FPS):
939,944c971,977
<                             'Clouds': False,
<                             'Vectorized Nozzle': True,
<                             'Graph': False,
<                             'Render': False,
<                             'Starting Y-Pos Constant': 1,
<                             'Initial Force': (0, 0)}
---
>                            'Clouds': False,
>                            'Vectorized Nozzle': True,
>                            'Graph': False,
>                            'Render': False,
>                            'Starting Y-Pos Constant': 1,
>                            'Initial Force': (0, 0)}
> 
955c988,989
<     delta_a = delta_x / 2 / eps # Jacobian
---
>     delta_a = delta_x / 2 / eps  # Jacobian
> 
957,958c991,992
<     u1 = np.tile(state, (len_action, 1)) + np.eye(len_action) * eps
<     u2 = np.tile(state, (len_action, 1)) - np.eye(len_action) * eps
---
>     u1 = np.tile(action, (len_action, 1)) + np.eye(len_action) * eps
>     u2 = np.tile(action, (len_action, 1)) - np.eye(len_action) * eps
961,962c995,998
<     delta_b = (f1 - f2)/2/eps
<     delta_b = delta_b.T
---
>     delta__b = (f1 - f2) / 2 / eps
>     delta__b = delta__b.T
> 
>     return delta_a, delta__b, delta_x
964d999
<     return delta_a, delta_b, delta_x
966d1000
< # ----------------------------------------------------------------------------
969c1003
<     envs = [None for _ in range(len(state))]
---
>     envs = [None for _ in range(len(state))]  # separate environment for memory management
972a1007
> 
986c1021
< # ----------------------------------------------------------------------------
---
> 
991,995d1025
< 
< 
< # ----------------------------------------------------------------------------
< # ----------------------------------------------------------------------------
< 
